#+SEQ_TODO: TODO SUJEET PRADEEP VVIP DONE
				Notes

* [2012-09-19 Wed] Performance
  CLOCK: [2012-09-19 Wed 21:29]--[2012-09-19 Wed 21:45] =>  0:16
* Problem Statement
** Word spell check - standalone words are given and you are supposed to suggest corrections.
** Phrase spell check - words present in a phrases need to be checked for spelling
** Sentence spell check - an entire sentence needs to be checked for spelling
* Input
** query1
** query2
** ...
* Output
** query{i} suggestion1 prob1 suggestion2 prob2 ...
** prob1 = P (suggestion1 | query{i})
* Metrics
** EP, ER, EF1
* Word spell-check
** Edit distance will suffice
** But to which distance will we consider alternative words?
** TODO Kernighan paper has the costs for the edits
* Phrase and sentence spell-check
** Context-sensitive spell-checking
* Paper 1 - A Data-driven approach for correcting search queries
  CLOCK: [2012-09-26 Wed 16:40]--[2012-09-26 Wed 18:00] =>  1:20
** Why purely data-driven?
*** Cos large datasets available
** Algo
*** Generation step - Postulate a set of alternative spellings
**** Check if it exists in the dictionary
**** If not, suggestion set = term + set of N_t suggestions from the dictionary
**** TODO How to trim the search space
*** Trimming and sorting - Use probability calculation
**** log (P (c|q)) = log (P (c)) - (r_e * lev (q, c)) / len (q)
**** r_e - unknown constant representing the error rate
**** Finally, normalize the probabilities
***** P (c_i | q) = relative probability
*** The parameters to be tuned
**** r_e (his final value = 36)
**** N_t (his final value = 2)
* Evaluation
** We need C (q), the set of all suggestions we produced for q, and the corresponding posterior probabilities P (c | q)
** TODO S (q) - set of human-annotated plausible spelling variations for q
* Code - SpellChecker
  CLOCK: [2012-09-26 Wed 13:10]--[2012-09-26 Wed 13:51] =>  0:41
** Training
*** Take in S (q) (?) or some training data
** DONE filter_valid_words (list of words) -> list of valid words OR is_in_dict (term) -> true or false
*** Store a list of dictionary words.
** DONE generate_candidate_terms (term) -> list of N_t candidate terms + the original term
*** Make sure it returns only valid terms.
*** Maybe do set intersection with the dictionary.
** SUJEET generate_candidate_suggestions (list of list of candidates for each term) -> list of candidate suggestions (phrases)
*** cross-product of the lists
** PRADEEP get_corrected_split_phrases (query) -> list of phrases consisting of split words joined together if it results in valid terms
   CLOCK: [2012-09-30 Sun 18:35]
*** Assumption: max two words will be joined.
** DONE get_corrected_run_on_phrases (query) -> list of phrases consisting of run-on words split if it results in valid terms
   CLOCK: [2012-09-30 Sun 17:12]--[2012-09-30 Sun 18:32] =>  1:20
   CLOCK: [2012-09-30 Sun 16:30]--[2012-09-30 Sun 17:11] =>  0:41
*** Assumption: max three words have been joined together.
*** Could have used this but went with the inefficient yet more Pythonic version
#+begin_src python
  def parts(list_, indices):
      # http://stackoverflow.com/questions/1198512/split-a-list-into-parts-based-on-a-set-of-indexes-in-python
      indices = [0]+indices+[len(list_)]
      return [list_[v:indices[k+1]] for k, v in enumerate(indices[:-1])]
#+end_src
** SUJEET get_prior (n-gram) -> prior probability for the n-gram
** SUJEET lev (c, q) -> edit distance with different costs for each operation
** SUJEET len (q)
** SUJEET get_normalized_probability (list of posterior probabilities) -> normalized list
** DONE generate_suggestions (q) -> [(suggestion, posterior), ...]
   CLOCK: [2012-09-30 Sun 16:15]--[2012-09-30 Sun 16:30] =>  0:15
   CLOCK: [2012-09-27 Thu 13:50]--[2012-09-27 Thu 14:26] =>  0:36
*** or C (q) and P (c | q)
** DONE evaluate_suggestions (q, C (q), P (c | q), S (q)) -> [EP, ER]
*** DONE get_EP
    CLOCK: [2012-09-27 Thu 12:17]--[2012-09-27 Thu 13:42] =>  1:25
*** DONE get_ER
    CLOCK: [2012-09-27 Thu 13:42]--[2012-09-27 Thu 13:46] =>  0:04
** DONE EF1 = HM (EP, ER)
** PRADEEP record_performance (EF1, Q)
** PRADEEP Script to test performance on different queries
